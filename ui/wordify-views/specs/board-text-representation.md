# Board Textual Representation (For deserialization / serialization.)

In some of our functions we will accept a 'board string' representation of the tiles on the board.

This string representation represents the board as a comma delimited string where each string is either a string representation of the tile
on the board square or an empty string. The string is ordered by column then row, starting at position A1 and ending at O15.

E.g. an empty board would be representated as 224 contiguous , characters.

Each string between commas is either:
* The string if it is a non-blank tile
* If it is a blank tile, then it is the string surrounded by square brackets

A board with the tile 'H' at position H8 and 'I' (where I is a blank tile with 'I' assigned) at position H9 would look like this:
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,H,[I],,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

## Example Encoding and Decoding Functions

Here is a haskell representation of functions to encode and decode this string representation:

textRepresentation :: Board -> String
textRepresentation board = L.intercalate "," (squareStrings board)
  where
    squareStrings :: Board -> [String]
    squareStrings board = map getLetterRepresentation (allSquares board)

    getLetterRepresentation :: (Pos, Square) -> String
    getLetterRepresentation square = toLetterRepresentation ((tileIfOccupied . snd) square)

    toLetterRepresentation :: Maybe Tile -> String
    toLetterRepresentation (Just (Letter str _)) = str
    toLetterRepresentation (Just (Blank (Just str))) = "[" ++ str ++ "]"
    toLetterRepresentation _ = ""

{-
  Loads a board from the string representation of the board generated by the 'textPresentation' function
-}
loadFromTextRepresentation :: M.Map String Tile -> String -> Maybe Board
loadFromTextRepresentation validTiles textRepresentation =
  let positionsWithTileString = L.zip [0 ..] (S.splitOn "," textRepresentation)
   in case sequence (map (uncurry positionWithLetter) positionsWithTileString) of
        Nothing -> Nothing
        Just maybePlacements -> placeTiles emptyBoard (catMaybes maybePlacements)
  where
    positionWithLetter :: Int -> String -> Maybe (Maybe (Tile, Pos))
    positionWithLetter oneDimensionalCoordinate [] = Just Nothing  -- Empty string, no tile (valid)
    positionWithLetter oneDimensionalCoordinate tileString = do
      tile <- extractBlank tileString <|> extractLetter validTiles tileString
      let x = (oneDimensionalCoordinate `div` 15) + 1
      let y = (oneDimensionalCoordinate `mod` 15) + 1
      coordinate <- posAt (x, y)
      return (Just (tile, coordinate))

    letterRepresentationToTile :: String -> Maybe Tile
    letterRepresentationToTile _ = undefined

    extractBlank :: String -> Maybe Tile
    extractBlank ('[' : xs)
      | not (null xs) && last xs == ']' = Just (Blank (Just (init xs)))
      | otherwise                       = Nothing
    extractBlank _ = Nothing

    extractLetter :: M.Map String Tile ->  String -> Maybe Tile
    extractLetter _ [] = Nothing
    extractLetter validTiles tileString = M.lookup tileString validTiles

## Library Functions

There is a function in src/common/board-text-presentation.ts for converting this string representation to the 'PlacedTile[]' type (PlacedTile is already defined in the library). The function is named
'fromBoardTextRepresentation.' It takes two parameters:

1. The string representing the board state
2. A map of 'string' to tile value that can be used to construct tiles with the appropriate values.

The function returns a sparse array of PlacedTile objects, where each PlacedTile contains:
- A position with 1-based x (column) and y (row) coordinates
- A TileInput object (either a LetterTileInput or BlankTileInput)

The function returns null if the board string is invalid (wrong length or unrecognized tile letters).